// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::METHOD_ID;
use core::{GameState, ShipType, Direction, Position};
use host::proofs::{GuestInput, produce_and_verify_proof, extract_round_commits};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // For demonstration we'll run a small RISC0 proof using a sample
    // `GuestInput` that mirrors the guest's expected input. In a real
    // game you would build this input from the current player's board
    // and the requested shots. We call `produce_and_verify_proof`, which
    // will attempt to run the local prover if the riscv toolchain is
    // available, otherwise it will return an explanatory error so
    // developers can continue iterating on host-side code.
    let mut state = GameState::new([0; 16]);
    // deterministic placements for demo (one of each ship)
    state.place_ship(ShipType::Carrier, Position::new(0,0), Direction::Horizontal);
    state.place_ship(ShipType::Battleship, Position::new(0,2), Direction::Horizontal);
    state.place_ship(ShipType::Cruiser, Position::new(0,4), Direction::Horizontal);
    state.place_ship(ShipType::Submarine, Position::new(0,6), Direction::Horizontal);
    state.place_ship(ShipType::Destroyer, Position::new(0,8), Direction::Horizontal);

    let guest_input = GuestInput { initial: state, shots: vec![Position::new(0,0)] };

    // Try to produce and verify a proof. If the local riscv toolchain / prover
    // is not available we print an explanatory message and exit gracefully so
    // developers can iterate on host code without requiring the guest/prover.
    match produce_and_verify_proof(&guest_input) {
        Ok(receipt) => {
            // Extract the sequence of commits (initial + per-round) recorded in the journal
            match extract_round_commits(&receipt) {
                Ok(commits) => {
                    println!("Extracted {} commit(s) from the receipt journal", commits.len());
                    for (i, c) in commits.iter().enumerate() {
                        // disambiguate AsRef so hex::encode knows which representation to use
                        let old_bytes: &[u8] = c.old_state.as_ref();
                        let new_bytes: &[u8] = c.new_state.as_ref();
                        println!(
                            "commit[{}]: old={} new={} shot={:?} hit={:?}",
                            i,
                            hex::encode(old_bytes),
                            hex::encode(new_bytes),
                            c.shot,
                            c.hit
                        );
                    }
                }
                Err(e) => {
                    eprintln!("Failed to extract commits from receipt: {}", e);
                }
            }

            if let Err(e) = receipt.verify(METHOD_ID) {
                eprintln!("Receipt verification failed: {}", e);
            } else {
                println!("Receipt verified successfully.");
            }
        }
        Err(e) => {
            eprintln!("Prover unavailable or failed: {}", e);
            eprintln!("To enable local proving, install the RISC0 toolchain (rzup/risc0 installer) and rebuild the workspace.");
            return;
        }
    }
}
