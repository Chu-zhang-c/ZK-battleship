// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use eframe::NativeOptions;
use host::ui::{BattleshipApp, UiEvent, UiCommand};

fn main() {
    // Init logging (kept from original binary behavior)
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Mitigate clipboard / XDG portal timeouts when running in environments
    // without a full desktop session (WSL without WSLg, headless CI, etc.).
    // These environment variables disable GTK's portal usage and ensure
    // there is a sane runtime dir so dependencies like arboard don't
    // immediately fail with broken-pipe errors when no clipboard manager
    // is available. Users on normal desktops can ignore this.
    std::env::set_var("GTK_USE_PORTAL", "0");
    if std::env::var_os("XDG_RUNTIME_DIR").is_none() {
        // Place a temporary runtime dir; this avoids some portal/clipboard
        // crates from assuming a real session socket is present.
        let _ = std::env::set_var("XDG_RUNTIME_DIR", "/tmp");
    }

    // Create channels between UI and core.
    let (tx_ui_cmd, rx_ui_evt, tx_core_evt, rx_core_cmd) = host::ui::make_channels();

    // Spawn a simple background thread that listens for UI commands and
    // replies with UI events. This is intentionally minimal: it demonstrates
    // integration and can later be replaced with the full GameCoordinator.
    std::thread::spawn(move || {
        // Local two-player demo logic powered by the UI thread.
        // Player 0 is the UI user; Player 1 is a deterministic opponent with
        // pre-placed ships. We maintain `local` (player 0) and `opponent` (player 1)
        // and an `opp_view` that contains the known hits/misses about opponent.
        let mut local = core::GameState::new([0u8; 16]);
        let mut opponent = core::GameState::new([0u8; 16]);
        let mut opp_view = core::GameState::new([0u8; 16]);

        // Deterministic placements (same as demo helper), so the UI can play.
        use core::{ShipType, Direction};
        local.place_ship(ShipType::Carrier, core::Position::new(0,0), Direction::Horizontal);
        local.place_ship(ShipType::Battleship, core::Position::new(0,2), Direction::Horizontal);
        local.place_ship(ShipType::Cruiser, core::Position::new(0,4), Direction::Horizontal);
        local.place_ship(ShipType::Submarine, core::Position::new(0,6), Direction::Horizontal);
        local.place_ship(ShipType::Destroyer, core::Position::new(0,8), Direction::Horizontal);

        opponent.place_ship(ShipType::Carrier, core::Position::new(0,0), Direction::Vertical);
        opponent.place_ship(ShipType::Battleship, core::Position::new(2,0), Direction::Vertical);
        opponent.place_ship(ShipType::Cruiser, core::Position::new(4,0), Direction::Vertical);
        opponent.place_ship(ShipType::Submarine, core::Position::new(6,0), Direction::Vertical);
        opponent.place_ship(ShipType::Destroyer, core::Position::new(8,0), Direction::Vertical);

        // Initial UI state updates
        let _ = tx_core_evt.send(UiEvent::LocalStateUpdated(local.clone()));
        let _ = tx_core_evt.send(UiEvent::OpponentViewUpdated(opp_view.clone()));
        let _ = tx_core_evt.send(UiEvent::Log("Local demo: click on opponent board to shoot".to_string()));

        let mut your_turn = true; // start with UI player's turn

        loop {
            match rx_core_cmd.recv() {
                Ok(cmd) => match cmd {
                    UiCommand::Shoot(pos) => {
                        if !pos.in_bounds() {
                            let _ = tx_core_evt.send(UiEvent::Log(format!("Invalid shot: ({}, {})", pos.x, pos.y)));
                            continue;
                        }

                        if !your_turn {
                            let _ = tx_core_evt.send(UiEvent::Log("Not your turn".to_string()));
                            continue;
                        }

                        // Check duplicate shot
                        if opp_view.grid[pos.y as usize][pos.x as usize] != core::CellState::Empty {
                            let _ = tx_core_evt.send(UiEvent::Log(format!("Already shot at ({}, {})", pos.x, pos.y)));
                            continue;
                        }

                        // Apply shot to opponent state
                        match opponent.apply_shot(pos) {
                            None => {
                                let _ = tx_core_evt.send(UiEvent::Log(format!("Invalid shot (oob or duplicate): ({}, {})", pos.x, pos.y)));
                            }
                            Some(hit) => {
                                // Update our view with hit/miss
                                match hit {
                                    core::HitType::Miss => {
                                        opp_view.grid[pos.y as usize][pos.x as usize] = core::CellState::Miss;
                                        your_turn = false; // miss -> turn passes
                                        let _ = tx_core_evt.send(UiEvent::Log(format!("Miss at ({}, {})", pos.x, pos.y)));
                                    }
                                    core::HitType::Hit => {
                                        opp_view.grid[pos.y as usize][pos.x as usize] = core::CellState::Hit;
                                        // hit -> keep turn
                                        let _ = tx_core_evt.send(UiEvent::Log(format!("Hit at ({}, {})", pos.x, pos.y)));
                                    }
                                    core::HitType::Sunk(st) => {
                                        opp_view.grid[pos.y as usize][pos.x as usize] = core::CellState::Hit;
                                        let _ = tx_core_evt.send(UiEvent::Log(format!("Sunk {:?} at ({}, {})", st, pos.x, pos.y)));
                                        // check if opponent all sunk
                                        if opponent.ships.iter().all(|s| s.is_sunk()) {
                                            let _ = tx_core_evt.send(UiEvent::OpponentViewUpdated(opp_view.clone()));
                                            let _ = tx_core_evt.send(UiEvent::GameOver(Some("You win".to_string())));
                                            break;
                                        }
                                        your_turn = false; // sunk -> pass
                                    }
                                }
                                // send updated opponent view
                                let _ = tx_core_evt.send(UiEvent::OpponentViewUpdated(opp_view.clone()));
                            }
                        }
                        // If turn passed to opponent, simulate a simple opponent move
                        if !your_turn {
                            // Simple AI: pick first empty cell scanning rows
                            'ai_search: for y in 0..(core::BOARD_SIZE as u32) {
                                for x in 0..(core::BOARD_SIZE as u32) {
                                    let p = core::Position::new(x, y);
                                    if local.grid[y as usize][x as usize] == core::CellState::Empty {
                                        // Apply shot
                                        if let Some(hit) = local.apply_shot(p) {
                                            match hit {
                                                core::HitType::Miss => {
                                                    let _ = tx_core_evt.send(UiEvent::Log(format!("Opponent missed at ({}, {})", x, y)));
                                                    // update local view for UI
                                                    let _ = tx_core_evt.send(UiEvent::LocalStateUpdated(local.clone()));
                                                    your_turn = true;
                                                    break 'ai_search;
                                                }
                                                core::HitType::Hit => {
                                                    let _ = tx_core_evt.send(UiEvent::Log(format!("Opponent hit at ({}, {})", x, y)));
                                                    let _ = tx_core_evt.send(UiEvent::LocalStateUpdated(local.clone()));
                                                    // opponent keeps going (naive)
                                                    continue;
                                                }
                                                core::HitType::Sunk(st) => {
                                                    let _ = tx_core_evt.send(UiEvent::Log(format!("Opponent sunk {:?} at ({}, {})", st, x, y)));
                                                    let _ = tx_core_evt.send(UiEvent::LocalStateUpdated(local.clone()));
                                                    if local.ships.iter().all(|s| s.is_sunk()) {
                                                        let _ = tx_core_evt.send(UiEvent::GameOver(Some("Opponent wins".to_string())));
                                                        break 'ai_search;
                                                    }
                                                    your_turn = true; // after sinking, pass back
                                                    break 'ai_search;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                Err(_) => break, // UI dropped
            }
        }
    });

    // Run the eframe application on the main thread.
    let native_options = NativeOptions::default();
    let _ = eframe::run_native(
        "ZK Battleship",
        native_options,
        Box::new(|_cc| Box::new(BattleshipApp::new(rx_ui_evt, tx_ui_cmd))),
    );

}
