// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use std::io::{self, Write};
use tracing_subscriber::{self, filter::{LevelFilter, filter_fn}, layer::SubscriberExt, util::SubscriberInitExt, Layer};

use host::game::{run_game_master_interactive, GameCoordinator};
use host::board_init::prompt_place_ships;
use host::network::NetworkConnection;

fn main() {
    // Hard-disable all tracing output from RISC0 and related proving crates by target prefix,
    // regardless of environment variables. Keep our own app logs at INFO.
    // This avoids extremely verbose prover/verification DEBUG noise during normal gameplay.
    let drop_risc_targets = filter_fn(|meta| {
        let t = meta.target();
        // Block common RISC0 crate targets and ark-* proving noise entirely
        !(t.starts_with("risc0") || t.starts_with("ark_"))
    });

    // Install a single global subscriber with two filters:
    // 1) Keep only INFO-and-above across the board
    // 2) Drop any event whose target starts with risc0* or ark_*
    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer()
            .with_filter(LevelFilter::INFO)
            .with_filter(drop_risc_targets)
        )
        .init();

    println!("=== ZK Battleship Host ===");

    loop {
        println!("Select an option:\n 1) Local 2-player (no network)\n 2) Host a networked game\n 3) Join a networked game\n 4) Exit");
        print!("> "); io::stdout().flush().ok();
        let mut choice = String::new();
        if io::stdin().read_line(&mut choice).is_err() {
            println!("failed to read input");
            continue;
        }
        match choice.trim() {
            "1" => {
                run_game_master_interactive();
            }
            "2" => {
                // Host a networked game
                print!("Port to listen on (default 7878): "); io::stdout().flush().ok();
                let mut port_s = String::new(); io::stdin().read_line(&mut port_s).ok();
                let port: u16 = port_s.trim().parse().unwrap_or(7878);

                print!("Player name: "); io::stdout().flush().ok();
                let mut name = String::new(); io::stdin().read_line(&mut name).ok();
                let name = name.trim().to_string();

                println!("{}: place your ships", name);
                let state = prompt_place_ships(&name);
                let commit = state.commit();

                match NetworkConnection::host(port) {
                    Ok(net) => {
                        let mut coord = GameCoordinator::new(state, commit, net, name.clone(), true);
                        if let Err(e) = coord.handshake() {
                            eprintln!("Handshake failed: {}", e);
                            continue;
                        }
                        if let Err(e) = coord.play_game() {
                            eprintln!("Game ended with error: {}", e);
                        }
                    }
                    Err(e) => eprintln!("Failed to start host: {}", e),
                }
            }
            "3" => {
                // Join a networked game
                print!("Host IP (default 127.0.0.1): "); io::stdout().flush().ok();
                let mut host = String::new(); io::stdin().read_line(&mut host).ok();
                let host = if host.trim().is_empty() { "127.0.0.1".to_string() } else { host.trim().to_string() };

                print!("Port (default 7878): "); io::stdout().flush().ok();
                let mut port_s = String::new(); io::stdin().read_line(&mut port_s).ok();
                let port: u16 = port_s.trim().parse().unwrap_or(7878);

                print!("Player name: "); io::stdout().flush().ok();
                let mut name = String::new(); io::stdin().read_line(&mut name).ok();
                let name = name.trim().to_string();

                println!("{}: place your ships", name);
                let state = prompt_place_ships(&name);
                let commit = state.commit();

                match NetworkConnection::connect(&host, port) {
                    Ok(net) => {
                        let mut coord = GameCoordinator::new(state, commit, net, name.clone(), false);
                        if let Err(e) = coord.handshake() {
                            eprintln!("Handshake failed: {}", e);
                            continue;
                        }
                        if let Err(e) = coord.play_game() {
                            eprintln!("Game ended with error: {}", e);
                        }
                    }
                    Err(e) => eprintln!("Failed to connect: {}", e),
                }
            }
            "4" => {
                println!("Goodbye");
                break;
            }
            other => {
                println!("Unknown option: {}", other);
            }
        }
    }
}
